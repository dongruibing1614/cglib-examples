package com.basaki.cglib;

import java.lang.reflect.Method;
import net.sf.cglib.proxy.CallbackHelper;
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.FixedValue;
import net.sf.cglib.proxy.InvocationHandler;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import net.sf.cglib.proxy.NoOp;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

/**
 * {@code EnhancerTest} is a test class for cglib {@code
 * net.sf.cglib.proxy.Enhancer}.  It is probably the most used class of the
 * cglib library. An enhancer allows the creation of Java proxies for
 * non-interface types. The Enhancer can be compared with the Java standard
 * library's Proxy class which was introduced in Java 1.3. The Enhancer
 * dynamically creates a subclass of a given type but intercepts all method
 * calls. Unlike {@code java.lang.reflect.Proxy} class, this works for both
 * class and interface types.
 *
 * @author Indra Basak
 * @since 11/2/17
 */
public class EnhancerTest {

    /**
     * Using cglib, the return value of test(String) method can easily be
     * replaced by another value using an Enhancer and a {@code FixedValue}
     * callback.
     * <p/>
     * The enhancer will return an instance of an instrumented subclass of
     * SampleClass where all method calls return a fixed value which is
     * generated by the anonymous FixedValue implementation above. The Enhancer
     * class cannot instrument constructors or static or final classes.
     *
     * @throws Exception
     */
    @Test(expected = ClassCastException.class)
    public void testFixedValue() throws Exception {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(SampleClass.class);
        enhancer.setCallback(new FixedValue() {
            @Override
            public Object loadObject() throws Exception {
                return "Hello cglib!";
            }
        });

        SampleClass proxy = (SampleClass) enhancer.create();
        assertEquals("Hello cglib!", proxy.test(null));

        // Be aware that any method call will be delegated in this example, also
        // calls to the methods defined in java.lang.Object. As a result, a
        // call to proxy.toString() will also return "Hello cglib!"
        assertEquals("Hello cglib!", proxy.toString());

        // final methods are not intercepted
        // the class names are generated randomly by cglib.
        // The class generated by cglib will however be in the same package
        // as the enhanced class (and therefore be able to override
        // package-private methods). Similar to final methods, the subclassing
        // approach makes for the inability of enhancing final classes.
        // Therefore frameworks as Hibernate cannot persist final classes.
        System.out.println("** " + proxy.getClass());

        // In contrast will a call to proxy.hashCode() result in a
        // ClassCastException since the FixedValue interceptor always
        // returns a String even though the Object#hashCode signature
        // requires a primitive integer.
        proxy.hashCode();
    }

    /**
     * Using cglib's {@code InvocationHandler}, the return value of methods
     * not belonging to Object.class and returning a String is replaced.
     * <p/>
     * This callback allows us to handle method involcations.
     * However, you should be careful when calling a method on the proxy object
     * that comes with the InvocationHandler#invoke method. All calls on this
     * method will be dispatched with the same InvocationHandler and might
     * result in an endless loop.
     *
     * @throws Exception
     */
    @Test(expected = RuntimeException.class)
    public void testInvocationHandler() throws Exception {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(SampleClass.class);
        enhancer.setCallback(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args)
                    throws Throwable {
                if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
                    return "Hello cglib!";
                } else {
                    throw new RuntimeException("Do not know what to do.");
                }
            }
        });
        SampleClass proxy = (SampleClass) enhancer.create();

        // call to method proxy.test(String arg) will return "Hello cglib!"
        // since the mrethod return type is String and the method
        // is not declared in Object.cclass
        assertEquals("Hello cglib!", proxy.test(null));

        // call to method test proxy.toString() will result in a
        // RuntimeException even though it returns a string. Because
        // it belongs to Object.class
        assertNotEquals("Hello cglib!", proxy.toString());
    }

    /**
     * The MethodInterceptor allows full control over the intercepted method
     * and
     * offers some utilities for calling the method of the enhanced class in
     * their original state. But why would one want to use other methods
     * anyways? Because the other methods are more efficient and cglib is often
     * used in edge case frameworks where efficiency plays a significant role.
     * The creation and linkage of the MethodInterceptor requires for example
     * the generation of a different type of byte code and the creation of some
     * runtime objects that are not required with the InvocationHandler.
     * Because
     * of that, there are other classes that can be used with the Enhancer:
     * <ol>
     * <p>
     * <li>LazyLoader: Even though the LazyLoader's only method has the same
     * method
     * signature as FixedValue, the LazyLoader is fundamentally different to
     * the
     * FixedValue interceptor. The LazyLoader is actually supposed to return an
     * instance of a subclass of the enhanced class. This instance is requested
     * only when a method is called on the enhanced object and then stored for
     * future invocations of the generated proxy. This makes sense if your
     * object is expensive in its creation without knowing if the object will
     * ever be used. Be aware that some constructor of the enhanced class must
     * be called both for the proxy object and for the lazily loaded object.
     * Thus, make sure that there is another cheap (maybe protected)
     * constructor
     * available or use an interface type for the proxy. You can choose the
     * invoked constructed by supplying arguments to Enhancer#create(Object...).
     * </li>
     * <p>
     * <li>
     * Dispatcher: The Dispatcher is like the LazyLoader but will be invoked on
     * every method call without storing the loaded object. This allows to
     * change the implementation of a class without changing the reference to
     * it. Again, be aware that some constructor must be called for both the
     * proxy and the generated objects. </li>
     * <p>
     * <li>ProxyRefDispatcher: This class carries a reference to the proxy
     * object it
     * is invoked from in its signature. This allows for example to delegate
     * method calls to another method of this proxy. Be aware that this can
     * easily cause an endless loop and will always cause an endless loop if
     * the
     * same method is called from within ProxyRefDispatcher#loadObject(Object).
     * </li>
     * <p>
     * <li>NoOp: The NoOp class does not what its name suggests. Instead, it
     * delegates each method call to the enhanced class's method
     * implementation.</li>
     * </ol>
     *
     * @throws Exception
     */
    @Test
    public void testMethodInterceptor() throws Exception {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(SampleClass.class);
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object obj, Method method, Object[] args,
                    MethodProxy proxy)
                    throws Throwable {
                if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
                    return "Hello cglib!";
                } else {
                    return proxy.invokeSuper(obj, args);
                }
            }
        });
        SampleClass proxy = (SampleClass) enhancer.create();
        assertEquals("Hello cglib!", proxy.test(null));
        assertNotEquals("Hello cglib!", proxy.toString());

        // doesn't throw an exception or result in an endless loop.
        proxy.hashCode();
    }

    /**
     * The Enhancer instance accepts a CallbackFilter in its
     * Enhancer#setCallbackFilter(CallbackFilter) method where it expects
     * methods of the enhanced class to be mapped to array indices of an array
     * of Callback instances. When a method is invoked on the created proxy, the
     * Enhancer will then choose the according interceptor and dispatch the
     * called method on the corresponding Callback (which is a marker interface
     * for all the interceptors that were introduced so far). To make this API
     * less awkward, cglib offers a CallbackHelper which will represent a
     * CallbackFilter and which can create an array of Callbacks for you. The
     * enhanced object above will be functionally equivalent to the one in the
     * example for the MethodInterceptor but it allows you to write specialized
     * interceptors whilst keeping the dispatching logic to these interceptors
     * separate.
     *
     * @throws Exception
     */
    @Test
    public void testCallbackFilter() throws Exception {
        Enhancer enhancer = new Enhancer();
        CallbackHelper callbackHelper =
                new CallbackHelper(SampleClass.class, new Class[0]) {
                    @Override
                    protected Object getCallback(Method method) {
                        if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
                            return new FixedValue() {
                                @Override
                                public Object loadObject() throws Exception {
                                    return "Hello cglib!";
                                }
                            };
                        } else {
                            return NoOp.INSTANCE; // A singleton provided by NoOp.
                        }
                    }
                };
        enhancer.setSuperclass(SampleClass.class);
        enhancer.setCallbackFilter(callbackHelper);
        enhancer.setCallbacks(callbackHelper.getCallbacks());
        SampleClass proxy = (SampleClass) enhancer.create();
        assertEquals("Hello cglib!", proxy.test(null));
        assertNotEquals("Hello cglib!", proxy.toString());

        // doesn't throw an exception or result in an endless loop.
        proxy.hashCode();
    }
}
